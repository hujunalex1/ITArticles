#变量和参数

对于变量和参数，不管是已经敲代码多年的老鸟，还是刚刚接触编程的小白，都会有时候清楚，有时候又有点模糊。因为，在实际应用中，它们之间分分离离，比如，敲代码都知道，x=3中x是变量，它不是参数，但是在函数y=3x+4中，x是变量，也是参数。那么什么这两个到底有什么区别和联系呢？我在网上搜了一下，发现很多说法，虽然大同小异，但是似乎只有下面这一段来自[微软网站](http://msdn.microsoft.com/zh-cn/library/9kewt1b3.aspx)的比较高度抽象，而且意义涵盖深远。我摘抄过来，看官读一读，是否理解，虽然是针对VB而言的，一样有启发。

>参数和变量之间的差异 (Visual Basic)

>多数情况下，过程必须包含有关调用环境的一些信息。执行重复或共享任务的过程对每次调用使用不同的信息。此信息包含每次调用过程时传递给它的变量、常量和表达式。

>若要将此信息传递给过程，过程先要定义一个形参，然后调用代码将一个实参传递给所定义的形参。 您可以将形参当作一个停车位，而将实参当作一辆汽车。 就像一个停车位可以在不同时间停放不同的汽车一样，调用代码在每次调用过程时可以将不同的实参传递给同一个形参。

>形参表示一个值，过程希望您在调用它时传递该值。

>当您定义 Function 或 Sub 过程时，需要在紧跟过程名称的括号内指定形参列表。对于每个形参，您可以指定名称、数据类型和传入机制（ByVal (Visual Basic) 或 ByRef (Visual Basic)）。您还可以指示某个形参是可选的。这意味着调用代码不必传递它的值。

>每个形参的名称均可作为过程内的局部变量。形参名称的使用方法与其他任何变量的使用方法相同。

>实参表示在您调用过程时传递给过程形参的值。调用代码在调用过程时提供参数。

>调用 Function 或 Sub 过程时，需要在紧跟过程名称的括号内包括实参列表。每个实参均与此列表中位于相同位置的那个形参相对应。

>与形参定义不同，实参没有名称。每个实参就是一个表达式，它包含零或多个变量、常数和文本。求值的表达式的数据类型通常应与为相应形参定义的数据类型相匹配，并且在任何情况下，该表达式值都必须可转换为此形参类型。

看官如果硬着头皮看完这段引文，发现里面有几个关键词：参数、变量、形参、实参。本来想弄清楚参数和变量，结果又冒出另外两个东东，更混乱了。请稍安勿躁，本来这段引文就是有点多余，但是，之所以引用，就是让列位开阔一下眼界，在编程业界，类似的东西有很多名词。下次听到有人说这些，不用害怕啦，反正自己听过了。

在Python中，没有这么复杂。

看完上面让人晕头转向的引文之后，再看下面的代码，就会豁然开朗了。

    >>> def add(x):     #x是参数
    ...     a = 10      #a是变量
    ...     return a+x
    ... 
    >>> x = 3           #x是变量，只不过在函数之外
    >>> add(x)          #这里的x是参数，但是它由前面的变量x传递对象3
    13
    >>> add(3)          #把上面的过程合并了
    13

至此，看官是否清楚了一点点。当然，我所表述不正确之处或者理解错误之处，也请看官不吝赐教，小可作揖感谢。

##全局变量和局部变量

下面是一段代码，注意这段代码中有一个函数funcx()，这个函数里面有一个变量x=9，在函数的前面也有一个变量x=2

    x = 2
     
    def funcx():
        x = 9
        print "this x is in the funcx:-->",x
         
    funcx()
    print "--------------------------"
    print "this x is out of funcx:-->",x

那么，这段代码输出的结果是什么呢？看：

    this x is in the funcx:--> 9
    --------------------------
    this x is out of funcx:--> 2

从输出看出，运行funcx()，输出了funcx()里面的变量x=9；然后执行代码中的最后一行，print "this x is out of funcx:-->",x

特别要关注的是，前一个x输出的是函数内部的变量x;后一个x输出的是函数外面的变量x。两个变量彼此没有互相影响，虽然都是x。从这里看出，两个X各自在各自的领域内起到作用，那么这样的变量称之为**局部变量**。

有局部，就有对应的全部，在汉语中，全部变量，似乎有歧义，幸亏汉语丰富，于是又取了一个名词：**全局变量**

    x = 2
    def funcx():
        global x
        x = 9
        print "this x is in the funcx:-->",x
          
    funcx()
        print "--------------------------"
        print "this x is out of funcx:-->",x

以上两段代码的不同之处在于，后者在函数内多了一个global x，这句话的意思是在声明x是全局变量，也就是说这个x跟函数外面的那个x同一个，接下来通过x=9将x的引用对象变成了9。所以，就出现了下面的结果。

    this x is in the funcx:--> 9
    --------------------------
    this x is out of funcx:--> 9

好似全局变量能力很强悍，能够统帅函数内外。但是，要注意，这个东西要慎重使用，因为往往容易带来变量的换乱。内外有别，在程序中一定要注意的。

##不确定参数的数量

在设计函数的时候，有时候我们能够确认参数的个数，比如一个用来计算圆面积的函数，它所需要的参数就是半径（πr^2），这个函数的参数是确定的。

然而，这个世界不总是这么简单的，也不总是这么确定的，反而不确定性是这个世界常常存在的。如果看官了解量子力学这个好多人听都没有听过的东西，那就理解真正的不确定性了。当然，不用研究量子力学也一样能够体会到，世界充满里了不确定性。不是吗？塞翁失马焉知非福，这不就是不确定性吗？

既然有很多不确定性，那么函数的参数的个数，也当然有不确定性，函数怎么解决这个问题呢？python用这样的方式解决参数个数的不确定性：

	def add(x,*arg):
	    print x         #输出参数x的值
	    result = x
	    print arg       #输出通过*arg方式得到的值
	    for i in arg:
	        result +=i
	    return result
	
	print add(1,2,3,4,5,6,7,8,9)    #赋给函数的参数个数不仅仅是2个

运行此代码后，得到如下结果：

    1                       #这是函数体内的第一个print，参数x得到的值是1
    (2, 3, 4, 5, 6, 7, 8, 9) #这是函数内的第二个print，参数arg得到的是一个元组
    45                      #最后的计算结果

上面这个输出的结果表现相当不界面友好，如果不对照着原函数，根本不知道每行打印的是什么东西。自责呀。

从上面例子可以看出，如果输入的参数过多，其它参数全部通过*arg，以元组的形式传给了参数（变量）arg。请看官注意，我这里用了一个模糊的词语：参数（变量），这样的表述意思是，在传入数据的前，arg在函数头部是参数，当在函数语句中，又用到了它，就是变量。也就是在很多时候，函数中的参数和变量是不用那么太区分较真的，只要知道对象是通过什么渠道、那个东西传到了什么目标即可。

为了能够更明显地看出*args（名称可以不一样，但是*符号必须要有），可以用下面的一个简单函数来演示：

    >>> def foo(*args):
    ...     print args      #打印通过这个参数得到的对象
    ... 
    >>> #下面演示分别传入不同的值，通过参数*args得到的结果

    >>> foo(1,2,3)
    (1, 2, 3)

    >>> foo("qiwsir","qiwsir.github.io","python")
    ('qiwsir', 'qiwsir.github.io', 'python')
    
    >>> foo("qiwsir",307,["qiwsir",2],{"name":"qiwsir","lang":"python"})
    ('qiwsir', 307, ['qiwsir', 2], {'lang': 'python', 'name': 'qiwsir'})
 
不管是什么，都一股脑地塞进了tuple中。

除了用*args这种形式的参数接收多个值之外，还可以用**kargs的形式接收数值，不过这次有点不一样：

    >>> def foo(**kargs):
    ...     print kargs
    ...
    >>> foo(a=1,b=2,c=3)    #注意观察这次赋值的方式和打印的结果
    {'a': 1, 'c': 3, 'b': 2}

如果这次还用foo(1,2,3)的方式，会有什么结果呢？

    >>> foo(1,2,3)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: foo() takes exactly 0 arguments (3 given)

看官到这里可能想了，不是不确定性吗？我也不知道参数到底会可能用什么样的方式传值呀，这好办，把上面的都综合起来。

    >>> def foo(x,y,z,*args,**kargs):
    ...     print x   
    ...     print y
    ...     print z
    ...     print args
    ...     print kargs        
    ... 
    >>> foo('qiwsir',2,"python")
    qiwsir
    2
    python
    ()
    {}
    >>> foo(1,2,3,4,5)
    1
    2
    3
    (4, 5)
    {}
    >>> foo(1,2,3,4,5,name="qiwsir")
    1
    2
    3
    (4, 5)
    {'name': 'qiwsir'}

很good了，这样就能够足以应付各种各样的参数要求了。
